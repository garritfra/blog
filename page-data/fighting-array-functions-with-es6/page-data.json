{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/fighting-array-functions-with-es6/","result":{"data":{"site":{"siteMetadata":{"title":"Garrits Blog","social":[{"name":"github","url":"https://github.com/garritfra"},{"name":"linkedin","url":"https://linkedin.com/in/garrit-franke-0558b1172"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"c492e215-f427-5fac-9550-2112bd99fe0d","excerpt":"Yesterday, I came across an interesting bug regarding JavaScript Arrays, and I wanted to share my approach to fixing it.\nAt a basic level, Iâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Fighting Array Functions with ES6\",\n  \"date\": \"2019-04-07T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Yesterday, I came across an interesting bug regarding JavaScript Arrays, and I wanted to share my approach to fixing it.\\nAt a basic level, I wanted to pass part of an array to a function, but wanted to use the original array later on.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let arr = [1, 2, 3, 4, 5]\\nlet something = arr.splice(0, 3)\\ndo(something) // []\\nDoSomethingWithOriginal(arr)\\n\")), mdx(\"p\", null, \"Thinking that Array.prototype functions don\\u2019t mutate the array directly, I moved on with my day. This lead to a bunch of problems down the line.\\nSome array methods in the EcmaScript specification are designed to mutate arrays, while others do not.\"), mdx(\"h3\", {\n    \"id\": \"non-mutating-functions\"\n  }, \"Non-mutating functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.map()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.slice()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.join()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u2026\")), mdx(\"p\", null, \"These functions do not mutate the array they are called on. For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let arr = [1, 2, 3, 4, 5]\\nlet partOfArr = arr.slice(1, 2)\\nconsole.log(partOfArr) // [2, 3]\\nconsole.log(arr) // [1, 2, 3, 4, 5]\\n\")), mdx(\"h3\", {\n    \"id\": \"mutating-functions\"\n  }, \"Mutating functions\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.sort()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.splice()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Array.prototype.reverse()\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u2026\")), mdx(\"p\", null, \"These methods mutate the array directly. This can lead to unreadable code, as the value can be manipulated from anywhere. For example:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let arr = [5, 2, 4]\\narr.sort()\\nconsole.log(arr) // [2, 4, 5]\\n\")), mdx(\"p\", null, \"To me, it is very unclear, which functions do, and which don\\u2019t mutate arrays directly. But, there\\u2019s a simple trick you can use to stop letting the functions mutate arrays directly, ultimately leading to more readable and reliable code.\"), mdx(\"h2\", {\n    \"id\": \"enter-the-es6-spread-operator\"\n  }, \"Enter: The ES6 Spread Operator!\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"https://images.unsplash.com/photo-1518297056586-889f796873e0?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1225&q=80\",\n    \"alt\": \"Spread Operator\"\n  }))), mdx(\"p\", null, \"Take a look at this snippet:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let arr = [3, 5, 1, 2, 4]\\nlet sorted = [...arr].sort()\\nconsole.log(arr) // [3, 5, 1, 2, 4]\\nconsole.log(sorted) // [1, 2, 3, 4, 5]\\n\")), mdx(\"p\", null, \"Voil\\xE0! We have a sorted array, and the original one is also around. The spread operator(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[...arr]\"), \") is used to create a new array with every value of arr .\\nYou can use this for arrays, as well as objects:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"let obj = {\\nfield: \\\"example\\\"\\n}\\nlet extendedObj = {\\n...obj,\\nanotherField: 42\\n}\\nconsole.log(extendedObj.field) // \\\"example\\\"\\n\")), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"ES6 brought us awesome features like let and const assignments, as well as arrow functions. A more unknown feature however is the spread operator. I hope you now know how to use the spread operator, and that you can adopt it for cleaner and simpler code.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/fighting-array-functions-with-es6/","title":"Fighting Array Functions with ES6","tags":[],"keywords":[],"date":"April 07, 2019"},"previous":null,"next":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"c492e215-f427-5fac-9550-2112bd99fe0d"}}}